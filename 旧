let userID = 'ffffffff-ffff-ffff-ffff-ffffffffffff';

import { connect } from 'cloudflare:sockets';

// WebSocket çŠ¶æ€å¸¸é‡
const WS_READY_STATE_OPEN = 1;
const WS_READY_STATE_CLOSING = 2;

// é»˜è®¤NAT64æœåŠ¡å™¨é…ç½®
const DEFAULT_NAT64_SERVERS = [
  { name: 'CloudFlare', prefix: '2001:67c:2960:6464', timeout: 5000 },
  { name: 'OpenDNS', prefix: '64:ff9b', timeout: 5000 },
  { name: 'DNS64.DNS.SB', prefix: '2001:67c:27e4:15::64', timeout: 5000 },
  { name: 'Google', prefix: '2001:4860:4860::6464', timeout: 5000 },
  { name: 'UltraTools', prefix: '2001:67c:2b0::4', timeout: 5000 }
];

// é»˜è®¤SOCKS5é…ç½®
const DEFAULT_SOCKS5_CONFIG = {
  host: '147.28.223.164',
  port: 1080,
  username: 'test123',
  password: 'test123',
  timeout: 10000,
  enabled: true
};

// å…¨å±€é…ç½®å¯¹è±¡
let RUNTIME_CONFIG = {
  socks5: {},
  nat64Servers: [],
  userID: '',
  dnsServer: 'https://1.1.1.1/dns-query'
};

// ä»KVå­˜å‚¨åŠ è½½é…ç½®
async function loadConfigFromKV(env) {
  const safeEnv = env || {};
  
  // ä¼˜å…ˆä»ç¯å¢ƒå˜é‡è¯»å–UUID
  RUNTIME_CONFIG.userID = safeEnv.UUID || userID;
  userID = RUNTIME_CONFIG.userID;

  // å°è¯•ä»KVè¯»å–SOCKS5é…ç½®
  if (safeEnv.CONFIG_KV) {
    try {
      const savedConfig = await safeEnv.CONFIG_KV.get('socks5_config', 'json');
      if (savedConfig) {
        RUNTIME_CONFIG.socks5 = savedConfig;
        console.log('ä»KVåŠ è½½SOCKS5é…ç½®æˆåŠŸ');
      } else {
        // KVä¸­æ²¡æœ‰é…ç½®ï¼Œä½¿ç”¨é»˜è®¤å€¼
        RUNTIME_CONFIG.socks5 = { ...DEFAULT_SOCKS5_CONFIG };
      }
    } catch (e) {
      console.error('ä»KVåŠ è½½é…ç½®å¤±è´¥:', e);
      RUNTIME_CONFIG.socks5 = { ...DEFAULT_SOCKS5_CONFIG };
    }
  } else {
    // æ²¡æœ‰KVç»‘å®šï¼Œä»ç¯å¢ƒå˜é‡è¯»å–æˆ–ä½¿ç”¨é»˜è®¤å€¼
    RUNTIME_CONFIG.socks5 = {
      host: safeEnv.SOCKS5_HOST || DEFAULT_SOCKS5_CONFIG.host,
      port: parseInt(safeEnv.SOCKS5_PORT || DEFAULT_SOCKS5_CONFIG.port),
      username: safeEnv.SOCKS5_USERNAME || DEFAULT_SOCKS5_CONFIG.username,
      password: safeEnv.SOCKS5_PASSWORD || DEFAULT_SOCKS5_CONFIG.password,
      timeout: parseInt(safeEnv.SOCKS5_TIMEOUT || DEFAULT_SOCKS5_CONFIG.timeout),
      enabled: (safeEnv.SOCKS5_ENABLED || 'true').toLowerCase() === 'true'
    };
  }

  RUNTIME_CONFIG.dnsServer = safeEnv.DNS_SERVER || RUNTIME_CONFIG.dnsServer;
  RUNTIME_CONFIG.nat64Servers = [...DEFAULT_NAT64_SERVERS];
}

// ä¿å­˜é…ç½®åˆ°KV
async function saveConfigToKV(env, config) {
  if (env && env.CONFIG_KV) {
    try {
      await env.CONFIG_KV.put('socks5_config', JSON.stringify(config));
      console.log('é…ç½®å·²ä¿å­˜åˆ°KV');
      return true;
    } catch (e) {
      console.error('ä¿å­˜é…ç½®åˆ°KVå¤±è´¥:', e);
      return false;
    }
  }
  return false;
}

// NAT64æœåŠ¡å™¨å¥åº·çŠ¶æ€ç®¡ç†
class NAT64Manager {
  constructor(servers) {
    this.servers = [...servers];
    this.healthStatus = new Map();
    this.lastHealthCheck = new Map();
    this.currentIndex = 0;
    
    this.servers.forEach((server, index) => {
      this.healthStatus.set(index, true);
      this.lastHealthCheck.set(index, 0);
    });
  }

  updateServers(servers) {
    this.servers = [...servers];
    this.healthStatus.clear();
    this.lastHealthCheck.clear();
    this.servers.forEach((server, index) => {
      this.healthStatus.set(index, true);
      this.lastHealthCheck.set(index, 0);
    });
    this.currentIndex = 0;
  }

  getNextServer() {
    const now = Date.now();
    
    for (let i = 0; i < this.servers.length; i++) {
      const index = (this.currentIndex + i) % this.servers.length;
      const lastCheck = this.lastHealthCheck.get(index);
      
      if (now - lastCheck > 60000 || this.healthStatus.get(index)) {
        this.currentIndex = index;
        return { ...this.servers[index], index: index };
      }
    }
    
    this.currentIndex = 0;
    return { ...this.servers[0], index: 0 };
  }

  markServerUnhealthy(index) {
    this.healthStatus.set(index, false);
    this.lastHealthCheck.set(index, Date.now());
  }

  markServerHealthy(index) {
    this.healthStatus.set(index, true);
    this.lastHealthCheck.set(index, Date.now());
  }

  getStatus() {
    return this.servers.map((server, index) => ({
      name: server.name,
      prefix: server.prefix,
      healthy: this.healthStatus.get(index),
      lastCheck: this.lastHealthCheck.get(index)
    }));
  }
}

let nat64Manager = new NAT64Manager(DEFAULT_NAT64_SERVERS);

// ç”Ÿæˆç®¡ç†ç½‘é¡µHTML
function generateWebPage(host, hasKV) {
  const vlessLink = `vless://${RUNTIME_CONFIG.userID}@${host}:443?encryption=none&security=tls&sni=${host}&type=ws&host=${host}&path=/#${host}`;
  
  return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VLESSé…ç½®ç®¡ç†</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 28px;
        }
        h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }
        .vless-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .vless-link {
            word-break: break-all;
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-family: monospace;
            font-size: 13px;
            color: #333;
            margin-top: 10px;
        }
        .copy-btn, .save-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 14px;
            transition: all 0.3s;
        }
        .copy-btn:hover, .save-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        .save-btn {
            background: #28a745;
            width: 100%;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: 500;
        }
        .save-btn:hover {
            background: #218838;
        }
        .save-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }
        input[type="text"],
        input[type="number"],
        input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        input:focus {
            outline: none;
            border-color: #667eea;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            cursor: pointer;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        .status-enabled {
            background: #d4edda;
            color: #155724;
        }
        .status-disabled {
            background: #f8d7da;
            color: #721c24;
        }
        .info-text {
            color: #666;
            font-size: 13px;
            margin-top: 5px;
        }
        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
        }
        .alert-success {
            background: #d4edda;
            border: 1px solid #28a745;
            color: #155724;
        }
        .alert-info {
            background: #d1ecf1;
            border: 1px solid #17a2b8;
            color: #0c5460;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .message {
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            display: none;
        }
        .message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>ğŸš€ VLESSä»£ç†é…ç½®ç®¡ç†</h1>
            <p class="subtitle">å®æ—¶ç®¡ç†æ‚¨çš„VLESSé“¾æ¥å’ŒSOCKS5ä»£ç†è®¾ç½®</p>
            
            ${!hasKV ? `
            <div class="alert alert-warning">
                âš ï¸ <strong>æœªç»‘å®šKVå­˜å‚¨</strong><br>
                å½“å‰ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®ã€‚è¦å¯ç”¨å®æ—¶é…ç½®åŠŸèƒ½ï¼Œè¯·ï¼š<br>
                1. åœ¨Cloudflareåˆ›å»ºä¸€ä¸ªKVå‘½åç©ºé—´<br>
                2. åœ¨Workerè®¾ç½®ä¸­ç»‘å®šKVï¼Œå˜é‡åè®¾ä¸º <code>CONFIG_KV</code><br>
                3. é‡æ–°éƒ¨ç½²åå³å¯å®æ—¶ä¿å­˜é…ç½®
            </div>
            ` : `
            <div class="alert alert-success">
                âœ… <strong>KVå­˜å‚¨å·²å¯ç”¨</strong> - é…ç½®ä¿®æ”¹ä¼šç«‹å³ç”Ÿæ•ˆï¼Œæ— éœ€é‡æ–°éƒ¨ç½²
            </div>
            `}

            <h2>ğŸ“¡ VLESSè¿æ¥é…ç½®</h2>
            <div class="vless-section">
                <strong>å½“å‰UUID:</strong> <code>${RUNTIME_CONFIG.userID}</code>
                <div class="vless-link">${vlessLink}</div>
                <button class="copy-btn" onclick="copyVlessLink()">ğŸ“‹ å¤åˆ¶VLESSé“¾æ¥</button>
            </div>

            <h2>ğŸ” SOCKS5ä»£ç†é…ç½®</h2>
            <form id="socks5Form" onsubmit="return false;">
                <div class="checkbox-group">
                    <input type="checkbox" id="enabled" ${RUNTIME_CONFIG.socks5.enabled ? 'checked' : ''}>
                    <label for="enabled">å¯ç”¨SOCKS5ä»£ç†</label>
                    <span class="status-badge ${RUNTIME_CONFIG.socks5.enabled ? 'status-enabled' : 'status-disabled'}">
                        ${RUNTIME_CONFIG.socks5.enabled ? 'å·²å¯ç”¨' : 'å·²ç¦ç”¨'}
                    </span>
                </div>

                <div class="grid">
                    <div class="form-group">
                        <label for="host">SOCKS5æœåŠ¡å™¨åœ°å€</label>
                        <input type="text" id="host" value="${RUNTIME_CONFIG.socks5.host}" required>
                    </div>
                    <div class="form-group">
                        <label for="port">ç«¯å£</label>
                        <input type="number" id="port" value="${RUNTIME_CONFIG.socks5.port}" required>
                    </div>
                </div>

                <div class="grid">
                    <div class="form-group">
                        <label for="username">ç”¨æˆ·å</label>
                        <input type="text" id="username" value="${RUNTIME_CONFIG.socks5.username}" required>
                    </div>
                    <div class="form-group">
                        <label for="password">å¯†ç </label>
                        <input type="password" id="password" value="${RUNTIME_CONFIG.socks5.password}" required>
                    </div>
                </div>

                <div class="form-group">
                    <label for="timeout">è¿æ¥è¶…æ—¶(æ¯«ç§’)</label>
                    <input type="number" id="timeout" value="${RUNTIME_CONFIG.socks5.timeout}" required>
                    <p class="info-text">å»ºè®®è®¾ç½®ä¸º5000-15000æ¯«ç§’</p>
                </div>

                <button type="button" class="save-btn" onclick="saveConfig()" ${!hasKV ? 'disabled' : ''}>
                    ${hasKV ? 'ğŸ’¾ ç«‹å³ä¿å­˜é…ç½®' : 'âŒ éœ€è¦ç»‘å®šKVå­˜å‚¨'}
                </button>
                <div id="saveMessage" class="message"></div>
            </form>
        </div>

        <div class="card">
            <h2>ğŸ“Š å½“å‰é…ç½®çŠ¶æ€</h2>
            <div class="vless-section">
                <p><strong>SOCKS5çŠ¶æ€:</strong> <span class="status-badge ${RUNTIME_CONFIG.socks5.enabled ? 'status-enabled' : 'status-disabled'}">${RUNTIME_CONFIG.socks5.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</span></p>
                <p><strong>SOCKS5æœåŠ¡å™¨:</strong> ${RUNTIME_CONFIG.socks5.host}:${RUNTIME_CONFIG.socks5.port}</p>
                <p><strong>NAT64æœåŠ¡å™¨æ•°é‡:</strong> ${RUNTIME_CONFIG.nat64Servers.length}ä¸ª</p>
                <p><strong>DNSæœåŠ¡å™¨:</strong> ${RUNTIME_CONFIG.dnsServer}</p>
                <p><strong>é…ç½®å­˜å‚¨:</strong> ${hasKV ? 'KVå­˜å‚¨ï¼ˆå®æ—¶ç”Ÿæ•ˆï¼‰' : 'ç¯å¢ƒå˜é‡ï¼ˆéœ€é‡å¯ï¼‰'}</p>
            </div>
        </div>
    </div>

    <script>
        const vlessLink = ${JSON.stringify(vlessLink)};
        const hasKV = ${hasKV};
        
        function copyVlessLink() {
            navigator.clipboard.writeText(vlessLink).then(() => {
                alert('âœ… VLESSé“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
            }).catch(() => {
                alert('âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
            });
        }

        async function saveConfig() {
            if (!hasKV) {
                alert('âŒ æœªç»‘å®šKVå­˜å‚¨ï¼Œæ— æ³•ä¿å­˜é…ç½®');
                return;
            }

            const saveBtn = document.querySelector('.save-btn');
            const message = document.getElementById('saveMessage');
            
            saveBtn.disabled = true;
            saveBtn.textContent = 'â³ ä¿å­˜ä¸­...';
            message.style.display = 'none';

            const config = {
                enabled: document.getElementById('enabled').checked,
                host: document.getElementById('host').value,
                port: parseInt(document.getElementById('port').value),
                username: document.getElementById('username').value,
                password: document.getElementById('password').value,
                timeout: parseInt(document.getElementById('timeout').value)
            };

            try {
                const response = await fetch('/api/save-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });

                const result = await response.json();

                if (result.success) {
                    message.className = 'message success';
                    message.textContent = 'âœ… é…ç½®ä¿å­˜æˆåŠŸï¼æ–°é…ç½®å·²ç«‹å³ç”Ÿæ•ˆ';
                    message.style.display = 'block';
                    
                    // 3ç§’ååˆ·æ–°é¡µé¢ä»¥æ˜¾ç¤ºæ–°é…ç½®
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else {
                    throw new Error(result.error || 'ä¿å­˜å¤±è´¥');
                }
            } catch (error) {
                message.className = 'message error';
                message.textContent = 'âŒ ä¿å­˜å¤±è´¥: ' + error.message;
                message.style.display = 'block';
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'ğŸ’¾ ç«‹å³ä¿å­˜é…ç½®';
            }
        }

        // ç›‘å¬å¯ç”¨çŠ¶æ€å˜åŒ–ï¼Œæ›´æ–°çŠ¶æ€å¾½ç« 
        document.getElementById('enabled').addEventListener('change', function() {
            const badge = document.querySelector('.checkbox-group .status-badge');
            if (this.checked) {
                badge.className = 'status-badge status-enabled';
                badge.textContent = 'å·²å¯ç”¨';
            } else {
                badge.className = 'status-badge status-disabled';
                badge.textContent = 'å·²ç¦ç”¨';
            }
        });
    </script>
</body>
</html>`;
}

export default {
  async fetch(request, env, ctx) {
    try {
      await loadConfigFromKV(env);
      nat64Manager.updateServers(RUNTIME_CONFIG.nat64Servers);
      
      const upgradeHeader = request.headers.get('Upgrade');
      if (!upgradeHeader || upgradeHeader.toLowerCase() !== 'websocket') {
        const url = new URL(request.url);
        
        // æ˜¾ç¤ºç®¡ç†ç½‘é¡µ
        if (url.pathname === '/' || url.pathname === '/admin') {
          const host = request.headers.get('Host');
          const hasKV = !!(env && env.CONFIG_KV);
          return new Response(generateWebPage(host, hasKV), {
            status: 200,
            headers: { 'Content-Type': 'text/html;charset=utf-8' },
          });
        }
        
        // API: ä¿å­˜é…ç½®
        if (url.pathname === '/api/save-config' && request.method === 'POST') {
          if (!env || !env.CONFIG_KV) {
            return new Response(JSON.stringify({
              success: false,
              error: 'æœªç»‘å®šKVå­˜å‚¨'
            }), {
              status: 400,
              headers: { 'Content-Type': 'application/json' }
            });
          }

          try {
            const newConfig = await request.json();
            
            // éªŒè¯é…ç½®
            if (!newConfig.host || !newConfig.port || !newConfig.username || !newConfig.password) {
              throw new Error('é…ç½®ä¿¡æ¯ä¸å®Œæ•´');
            }

            // ä¿å­˜åˆ°KV
            const saved = await saveConfigToKV(env, newConfig);
            
            if (saved) {
              // æ›´æ–°è¿è¡Œæ—¶é…ç½®
              RUNTIME_CONFIG.socks5 = newConfig;
              
              return new Response(JSON.stringify({
                success: true,
                message: 'é…ç½®ä¿å­˜æˆåŠŸ'
              }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' }
              });
            } else {
              throw new Error('ä¿å­˜åˆ°KVå¤±è´¥');
            }
          } catch (error) {
            return new Response(JSON.stringify({
              success: false,
              error: error.message
            }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            });
          }
        }
        
        // API: è·å–å½“å‰é…ç½®
        if (url.pathname === '/api/config') {
          return new Response(JSON.stringify({
            uuid: RUNTIME_CONFIG.userID,
            socks5: RUNTIME_CONFIG.socks5,
            nat64Servers: RUNTIME_CONFIG.nat64Servers,
            dnsServer: RUNTIME_CONFIG.dnsServer
          }, null, 2), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
          });
        }
        
        // çŠ¶æ€æŸ¥è¯¢
        if (url.pathname === '/status') {
          const status = {
            configuration: {
              uuid: RUNTIME_CONFIG.userID.substring(0, 8) + '***',
              socks5: {
                host: RUNTIME_CONFIG.socks5.host,
                port: RUNTIME_CONFIG.socks5.port,
                enabled: RUNTIME_CONFIG.socks5.enabled,
                timeout: RUNTIME_CONFIG.socks5.timeout
              },
              dns_server: RUNTIME_CONFIG.dnsServer
            },
            nat64_servers: nat64Manager.getStatus()
          };
          return new Response(JSON.stringify(status, null, 2), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
          });
        }
        
        // UUIDè·¯å¾„è¿”å›VLESSé“¾æ¥
        if (url.pathname === `/${RUNTIME_CONFIG.userID}`) {
          const host = request.headers.get('Host');
          const vlessConfig = `vless://${RUNTIME_CONFIG.userID}@${host}:443?encryption=none&security=tls&sni=${host}&type=ws&host=${host}&path=/#${host}`;
          return new Response(vlessConfig, {
            status: 200,
            headers: { 'Content-Type': 'text/plain;charset=utf-8' },
          });
        }
        
        return new Response('Not Found', { status: 404 });
      }
      
      return await handleVLESSWebSocket(request);
    } catch (err) {
      return new Response(err.toString(), { status: 500 });
    }
  },
};

// ä»¥ä¸‹ä¿æŒåŸæœ‰çš„WebSocketå¤„ç†å‡½æ•°ä¸å˜
async function handleVLESSWebSocket(request) {
  const wsPair = new WebSocketPair();
  const [clientWS, serverWS] = Object.values(wsPair);
  serverWS.accept();

  const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';
  const wsReadable = createWebSocketReadableStream(serverWS, earlyDataHeader);
  let remoteSocket = null;
  let udpStreamWrite = null;
  let isDns = false;
  
  wsReadable.pipeTo(new WritableStream({
    async write(chunk) {
      if (isDns && udpStreamWrite) {
        return udpStreamWrite(chunk);
      }
      
      if (remoteSocket) {
        const writer = remoteSocket.writable.getWriter();
        await writer.write(chunk);
        writer.releaseLock();
        return;
      }

      const result = parseVLESSHeader(chunk, RUNTIME_CONFIG.userID);
      if (result.hasError) {
        throw new Error(result.message);
      }

      const vlessRespHeader = new Uint8Array([result.vlessVersion[0], 0]);
      const rawClientData = chunk.slice(result.rawDataIndex);
      
      if (result.isUDP) {
        if (result.portRemote === 53) {
          isDns = true;
          const { write } = await handleUDPOutBound(serverWS, vlessRespHeader);
          udpStreamWrite = write;
          udpStreamWrite(rawClientData);
          return;
        } else {
          throw new Error('UDPä»£ç†ä»…æ”¯æŒDNS(ç«¯å£53)');
        }
      }

      try {
        if (RUNTIME_CONFIG.socks5.enabled) {
          try {
            const socks5Socket = await connectViaSocks5(result.addressRemote, result.portRemote, rawClientData);
            remoteSocket = socks5Socket;
            pipeRemoteToWebSocket(socks5Socket, serverWS, vlessRespHeader, null);
            return;
          } catch (socks5Error) {
            console.error('SOCKS5è¿æ¥å¤±è´¥:', socks5Error.message);
          }
        }
        
        try {
          const tcpSocket = await tryNAT64Connect(result.addressRemote, result.portRemote, rawClientData);
          remoteSocket = tcpSocket;
          pipeRemoteToWebSocket(tcpSocket, serverWS, vlessRespHeader, null);
        } catch (nat64Error) {
          console.error('NAT64è¿æ¥å¤±è´¥:', nat64Error.message);
          
          try {
            const tcpSocket = await directConnect(result.addressRemote, result.portRemote, rawClientData);
            remoteSocket = tcpSocket;
            pipeRemoteToWebSocket(tcpSocket, serverWS, vlessRespHeader, null);
          } catch (directError) {
            console.error('ç›´æ¥è¿æ¥å¤±è´¥:', directError.message);
            serverWS.close(1011, 'æ‰€æœ‰è¿æ¥æ–¹å¼éƒ½å¤±è´¥');
          }
        }
      } catch (generalError) {
        console.error('è¿æ¥è¿‡ç¨‹ä¸­å‡ºç°æ„å¤–é”™è¯¯:', generalError);
        serverWS.close(1011, `è¿æ¥å¤±è´¥: ${generalError.message}`);
      }
    },
    close() {
      if (remoteSocket) {
        closeSocket(remoteSocket);
      }
    }
  })).catch(err => {
    console.error('WebSocket é”™è¯¯:', err);
    closeSocket(remoteSocket);
    serverWS.close(1011, 'å†…éƒ¨é”™è¯¯');
  });

  return new Response(null, {
    status: 101,
    webSocket: clientWS,
  });
}

async function connectViaSocks5(targetHost, targetPort, rawClientData) {
  const socks5Socket = await connect({
    hostname: RUNTIME_CONFIG.socks5.host,
    port: RUNTIME_CONFIG.socks5.port
  });

  const writer = socks5Socket.writable.getWriter();
  const reader = socks5Socket.readable.getReader();

  try {
    const authMethods = new Uint8Array([0x05, 0x01, 0x02]);
    await writer.write(authMethods);
    const authResponse = await reader.read();
    const authData = new Uint8Array(authResponse.value);
    
    if (authData[0] !== 0x05 || authData[1] !== 0x02) {
      throw new Error('SOCKS5è®¤è¯æ–¹æ³•åå•†å¤±è´¥');
    }

    const username = new TextEncoder().encode(RUNTIME_CONFIG.socks5.username);
    const password = new TextEncoder().encode(RUNTIME_CONFIG.socks5.password);
    const authPacket = new Uint8Array(3 + username.length + password.length);
    
    authPacket[0] = 0x01;
    authPacket[1] = username.length;
    authPacket.set(username, 2);
    authPacket[2 + username.length] = password.length;
    authPacket.set(password, 3 + username.length);
    
    await writer.write(authPacket);
    const authResult = await reader.read();
    const authResultData = new Uint8Array(authResult.value);
    
    if (authResultData.length < 2 || authResultData[1] !== 0x00) {
      throw new Error('SOCKS5ç”¨æˆ·åå¯†ç è®¤è¯å¤±è´¥');
    }

    const hostBytes = new TextEncoder().encode(targetHost);
    const connectPacket = new Uint8Array(7 + hostBytes.length);
    
    connectPacket[0] = 0x05;
    connectPacket[1] = 0x01;
    connectPacket[2] = 0x00;
    connectPacket[3] = 0x03;
    connectPacket[4] = hostBytes.length;
    connectPacket.set(hostBytes, 5);
    connectPacket[5 + hostBytes.length] = (targetPort >> 8) & 0xFF;
    connectPacket[6 + hostBytes.length] = targetPort & 0xFF;
    
    await writer.write(connectPacket);
    const connectResponse = await reader.read();
    const connectData = new Uint8Array(connectResponse.value);
    
    if (connectData.length < 2 || connectData[1] !== 0x00) {
      throw new Error(`SOCKS5è¿æ¥å¤±è´¥ï¼Œé”™è¯¯ç : ${connectData[1]}`);
    }

    reader.releaseLock();
    writer.releaseLock();

    const dataWriter = socks5Socket.writable.getWriter();
    await dataWriter.write(rawClientData);
    dataWriter.releaseLock();

    return socks5Socket;
  } catch (err) {
    try {
      reader.releaseLock();
      writer.releaseLock();
    } catch (e) {}
    closeSocket(socks5Socket);
    throw err;
  }
}

async function tryNAT64Connect(domain, port, rawClientData) {
  let lastError = null;
  
  for (let attempt = 0; attempt < RUNTIME_CONFIG.nat64Servers.length; attempt++) {
    const nat64Server = nat64Manager.getNextServer();
    
    try {
      const proxyIP = await getIPv6ProxyAddress(domain, nat64Server);
      const connectPromise = connect({ hostname: proxyIP, port: port });
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('è¿æ¥è¶…æ—¶')), nat64Server.timeout);
      });
      
      const tcpSocket = await Promise.race([connectPromise, timeoutPromise]);
      nat64Manager.markServerHealthy(nat64Server.index);
      
      const writer = tcpSocket.writable.getWriter();
      await writer.write(rawClientData);
      writer.releaseLock();
      
      return tcpSocket;
    } catch (err) {
      lastError = err;
      nat64Manager.markServerUnhealthy(nat64Server.index);
      
      if (attempt < RUNTIME_CONFIG.nat64Servers.length - 1) {
        continue;
      }
    }
  }
  
  throw new Error(`æ‰€æœ‰NAT64æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼Œæœ€åé”™è¯¯: ${lastError?.message}`);
}

async function directConnect(address, port, rawClientData) {
  const tcpSocket = await connect({ hostname: address, port: port });
  const writer = tcpSocket.writable.getWriter();
  await writer.write(rawClientData);
  writer.releaseLock();
  return tcpSocket;
}

async function getIPv6ProxyAddress(domain, nat64Server) {
  const dnsQuery = await fetch(`${RUNTIME_CONFIG.dnsServer}?name=${domain}&type=A`, {
    headers: { 'Accept': 'application/dns-json' }
  });
  
  const dnsResult = await dnsQuery.json();
  if (dnsResult.Answer && dnsResult.Answer.length > 0) {
    const aRecord = dnsResult.Answer.find(record => record.type === 1);
    if (aRecord) {
      const ipv4Address = aRecord.data;
      return convertToNAT64IPv6(ipv4Address, nat64Server.prefix);
    }
  }
  throw new Error('æ— æ³•è§£æåŸŸåçš„IPv4åœ°å€');
}

function convertToNAT64IPv6(ipv4Address, nat64Prefix) {
  const parts = ipv4Address.split('.');
  if (parts.length !== 4) throw new Error('æ— æ•ˆçš„IPv4åœ°å€');
  
  const hex = parts.map(part => {
    const num = parseInt(part, 10);
    if (num < 0 || num > 255) throw new Error('æ— æ•ˆçš„IPv4åœ°å€æ®µ');
    return num.toString(16).padStart(2, '0');
  });
  
  if (nat64Prefix === '64:ff9b') {
    return `[64:ff9b::${hex[0]}${hex[1]}:${hex[2]}${hex[3]}]`;
  } else if (nat64Prefix.includes('::')) {
    return `[${nat64Prefix}:${hex[0]}${hex[1]}:${hex[2]}${hex[3]}]`;
  } else {
    return `[${nat64Prefix}::${hex[0]}${hex[1]}:${hex[2]}${hex[3]}]`;
  }
}

function createWebSocketReadableStream(ws, earlyDataHeader) {
  return new ReadableStream({
    start(controller) {
      ws.addEventListener('message', event => {
        controller.enqueue(event.data);
      });
      
      ws.addEventListener('close', () => {
        controller.close();
      });
      
      ws.addEventListener('error', err => {
        controller.error(err);
      });
      
      if (earlyDataHeader) {
        try {
          const decoded = atob(earlyDataHeader.replace(/-/g, '+').replace(/_/g, '/'));
          const data = Uint8Array.from(decoded, c => c.charCodeAt(0));
          controller.enqueue(data.buffer);
        } catch (e) {}
      }
    }
  });
}

function parseVLESSHeader(buffer, userID) {
  if (buffer.byteLength < 24) {
    return { hasError: true, message: 'æ— æ•ˆçš„å¤´éƒ¨é•¿åº¦' };
  }
  
  const view = new DataView(buffer);
  const version = new Uint8Array(buffer.slice(0, 1));
  
  const uuid = formatUUID(new Uint8Array(buffer.slice(1, 17)));
  if (uuid !== userID) {
    return { hasError: true, message: 'æ— æ•ˆçš„ç”¨æˆ·' };
  }
  
  const optionsLength = view.getUint8(17);
  const command = view.getUint8(18 + optionsLength);
  
  let isUDP = false;
  if (command === 1) {
  } else if (command === 2) {
    isUDP = true;
  } else {
    return { hasError: true, message: 'ä¸æ”¯æŒçš„å‘½ä»¤ï¼Œä»…æ”¯æŒTCP(01)å’ŒUDP(02)' };
  }
  
  let offset = 19 + optionsLength;
  const port = view.getUint16(offset);
  offset += 2;
  
  const addressType = view.getUint8(offset++);
  let address = '';
  
  switch (addressType) {
    case 1:
      address = Array.from(new Uint8Array(buffer.slice(offset, offset + 4))).join('.');
      offset += 4;
      break;
      
    case 2:
      const domainLength = view.getUint8(offset++);
      address = new TextDecoder().decode(buffer.slice(offset, offset + domainLength));
      offset += domainLength;
      break;
      
    case 3:
      const ipv6 = [];
      for (let i = 0; i < 8; i++) {
        ipv6.push(view.getUint16(offset).toString(16).padStart(4, '0'));
        offset += 2;
      }
      address = ipv6.join(':').replace(/(^|:)0+(\w)/g, '$1$2');
      break;
      
    default:
      return { hasError: true, message: 'ä¸æ”¯æŒçš„åœ°å€ç±»å‹' };
  }
  
  return {
    hasError: false,
    addressRemote: address,
    portRemote: port,
    rawDataIndex: offset,
    vlessVersion: version,
    isUDP
  };
}

function pipeRemoteToWebSocket(remoteSocket, ws, vlessHeader, retry = null) {
  let headerSent = false;
  let hasIncomingData = false;
  
  remoteSocket.readable.pipeTo(new WritableStream({
    write(chunk) {
      hasIncomingData = true;
      if (ws.readyState === WS_READY_STATE_OPEN) {
        if (!headerSent) {
          const combined = new Uint8Array(vlessHeader.byteLength + chunk.byteLength);
          combined.set(new Uint8Array(vlessHeader), 0);
          combined.set(new Uint8Array(chunk), vlessHeader.byteLength);
          ws.send(combined.buffer);
          headerSent = true;
        } else {
          ws.send(chunk);
        }
      }
    },
    close() {
      if (!hasIncomingData && retry) {
        retry();
        return;
      }
      if (ws.readyState === WS_READY_STATE_OPEN) {
        ws.close(1000, 'æ­£å¸¸å…³é—­');
      }
    },
    abort() {
      closeSocket(remoteSocket);
    }
  })).catch(err => {
    console.error('æ•°æ®è½¬å‘é”™è¯¯:', err);
    closeSocket(remoteSocket);
    if (ws.readyState === WS_READY_STATE_OPEN) {
      ws.close(1011, 'æ•°æ®ä¼ è¾“é”™è¯¯');
    }
  });
}

function closeSocket(socket) {
  if (socket) {
    try {
      socket.close();
    } catch (e) {}
  }
}

function formatUUID(bytes) {
  const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
  return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
}

async function handleUDPOutBound(webSocket, vlessResponseHeader) {
  let isVlessHeaderSent = false;
  const transformStream = new TransformStream({
    start(controller) {},
    transform(chunk, controller) {
      for (let index = 0; index < chunk.byteLength;) {
        const lengthBuffer = chunk.slice(index, index + 2);
        const udpPacketLength = new DataView(lengthBuffer).getUint16(0);
        const udpData = new Uint8Array(
          chunk.slice(index + 2, index + 2 + udpPacketLength)
        );
        index = index + 2 + udpPacketLength;
        controller.enqueue(udpData);
      }
    },
    flush(controller) {}
  });

  transformStream.readable.pipeTo(new WritableStream({
    async write(chunk) {
      const resp = await fetch(RUNTIME_CONFIG.dnsServer, {
        method: 'POST',
        headers: { 'content-type': 'application/dns-message' },
        body: chunk,
      });
      const dnsQueryResult = await resp.arrayBuffer();
      const udpSize = dnsQueryResult.byteLength;
      const udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]);
      
      if (webSocket.readyState === WS_READY_STATE_OPEN) {
        if (isVlessHeaderSent) {
          webSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer());
        } else {
          webSocket.send(await new Blob([vlessResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer());
          isVlessHeaderSent = true;
        }
      }
    }
  })).catch((error) => {
    console.error('DNS UDPå¤„ç†é”™è¯¯:', error);
  });

  const writer = transformStream.writable.getWriter();

  return {
    write(chunk) {
      writer.write(chunk);
    }
  };
}
