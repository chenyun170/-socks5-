let userID = 'ffffffff-ffff-ffff-ffff-ffffffffffff';

import { connect } from 'cloudflare:sockets';

const WS_READY_STATE_OPEN = 1;
const WS_READY_STATE_CLOSING = 2;

const DEFAULT_NAT64_SERVERS = [
  { name: 'CloudFlare', prefix: '2001:67c:2960:6464', timeout: 5000 },
  { name: 'OpenDNS', prefix: '64:ff9b', timeout: 5000 },
  { name: 'DNS64.DNS.SB', prefix: '2001:67c:27e4:15::64', timeout: 5000 },
  { name: 'Google', prefix: '2001:4860:4860::6464', timeout: 5000 },
  { name: 'UltraTools', prefix: '2001:67c:2b0::4', timeout: 5000 }
];

let RUNTIME_CONFIG = {
  socks5: null,  // é»˜è®¤ä¸ºç©ºï¼Œé€šè¿‡URLå‚æ•°è®¾ç½®
  nat64Servers: [...DEFAULT_NAT64_SERVERS],
  userID: '',
  dnsServer: 'https://1.1.1.1/dns-query'
};

// è§£æSOCKSä»£ç†URL
function parseProxyURL(proxyUrl) {
  try {
    // æ”¯æŒæ ¼å¼:
    // socks://host:port
    // socks5://host:port
    // socks://user:password@host:port
    // socks5://user:password@host:port
    
    const url = new URL(proxyUrl);
    
    if (!['socks:', 'socks5:'].includes(url.protocol)) {
      throw new Error('ä»…æ”¯æŒ socks:// æˆ– socks5:// åè®®');
    }
    
    const config = {
      host: url.hostname,
      port: parseInt(url.port) || 1080,
      username: url.username || '',
      password: url.password || '',
      timeout: 10000,
      enabled: true
    };
    
    if (!config.host) {
      throw new Error('ç¼ºå°‘ä¸»æœºåœ°å€');
    }
    
    return config;
  } catch (error) {
    throw new Error(`ä»£ç†URLè§£æå¤±è´¥: ${error.message}`);
  }
}

// ä»URLå‚æ•°ä¸­æå–é…ç½®
function extractConfigFromURL(url) {
  const params = url.searchParams;
  const proxyip = params.get('proxyip');
  const ed = params.get('ed');
  
  let socks5Config = null;
  
  if (proxyip) {
    try {
      socks5Config = parseProxyURL(proxyip);
    } catch (error) {
      console.error('è§£æproxyipå¤±è´¥:', error.message);
      return { error: error.message };
    }
  }
  
  return {
    socks5: socks5Config,
    ed: ed
  };
}

async function loadConfigFromKV(env) {
  const safeEnv = env || {};
  RUNTIME_CONFIG.userID = safeEnv.UUID || userID;
  userID = RUNTIME_CONFIG.userID;
  RUNTIME_CONFIG.dnsServer = safeEnv.DNS_SERVER || RUNTIME_CONFIG.dnsServer;
}

function generateWebPage(host, currentConfig) {
  const hasConfig = currentConfig && currentConfig.socks5;
  const error = currentConfig?.error;
  
  // ç”Ÿæˆç¤ºä¾‹URL
  const exampleUrl1 = `https://${host}/?proxyip=socks5://proxy.example.com:1080`;
  const exampleUrl2 = `https://${host}/?proxyip=socks5://user:pass@proxy.example.com:1080`;
  const exampleUrl3 = `https://${host}/?ed=2560&proxyip=socks5://user:pass@proxy.example.com:1080`;
  
  // ç”ŸæˆVLESSé“¾æ¥
  let vlessLink = '';
  if (hasConfig) {
    const proxyParam = encodeURIComponent(`socks5://${currentConfig.socks5.username}:${currentConfig.socks5.password}@${currentConfig.socks5.host}:${currentConfig.socks5.port}`);
    const path = `/?proxyip=${proxyParam}`;
    vlessLink = `vless://${RUNTIME_CONFIG.userID}@${host}:443?encryption=none&security=tls&sni=${host}&type=ws&host=${host}&path=${encodeURIComponent(path)}#SOCKS5-${currentConfig.socks5.host}`;
  }

  return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨æ€SOCKS5ä»£ç†é…ç½®</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 28px;
        }
        h2 {
            color: #333;
            margin: 20px 0 15px 0;
            font-size: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        .alert-info {
            background: #d1ecf1;
            border: 1px solid #17a2b8;
            color: #0c5460;
        }
        .alert-success {
            background: #d4edda;
            border: 1px solid #28a745;
            color: #155724;
        }
        .alert-error {
            background: #f8d7da;
            border: 1px solid #dc3545;
            color: #721c24;
        }
        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
        }
        .example-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        .code {
            background: white;
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            word-break: break-all;
            border: 1px solid #ddd;
            margin: 10px 0;
            color: #333;
        }
        .config-form {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }
        input[type="text"],
        input[type="number"],
        input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        input:focus {
            outline: none;
            border-color: #667eea;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            width: 100%;
        }
        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        .copy-btn {
            background: #28a745;
            margin-top: 10px;
        }
        .copy-btn:hover {
            background: #218838;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .info-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
        }
        .info-label {
            color: #666;
            font-size: 13px;
            margin-bottom: 5px;
        }
        .info-value {
            color: #333;
            font-weight: 500;
            font-family: monospace;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        .status-active {
            background: #d4edda;
            color: #155724;
        }
        .status-inactive {
            background: #f8d7da;
            color: #721c24;
        }
        ul {
            margin-left: 20px;
            line-height: 1.8;
        }
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>ğŸš€ åŠ¨æ€SOCKS5ä»£ç†é…ç½®</h1>
            <p class="subtitle">
                é€šè¿‡URLå‚æ•°åŠ¨æ€è®¾ç½®SOCKS5ä»£ç†ï¼Œæ— éœ€ä¿®æ”¹ä»£ç ã€‚æ”¯æŒéšæ—¶åˆ‡æ¢ä¸åŒçš„ä»£ç†æœåŠ¡å™¨ã€‚
            </p>
            
            ${error ? `
            <div class="alert alert-error">
                <strong>âŒ é…ç½®é”™è¯¯:</strong> ${error}
            </div>
            ` : ''}
            
            ${!hasConfig ? `
            <div class="alert alert-info">
                <strong>ğŸ’¡ ä½¿ç”¨è¯´æ˜:</strong><br>
                å½“å‰æœªé…ç½®SOCKS5ä»£ç†ã€‚è¯·åœ¨URLä¸­æ·»åŠ  <code>proxyip</code> å‚æ•°æ¥è®¾ç½®ä»£ç†ã€‚
            </div>
            ` : `
            <div class="alert alert-success">
                <strong>âœ… ä»£ç†å·²é…ç½®</strong><br>
                å½“å‰æ­£åœ¨ä½¿ç”¨: ${currentConfig.socks5.host}:${currentConfig.socks5.port}
                ${currentConfig.socks5.username ? ` (è®¤è¯: ${currentConfig.socks5.username})` : ' (æ— è®¤è¯)'}
            </div>
            `}

            <h2>ğŸ“ å¿«é€Ÿé…ç½®</h2>
            <div class="config-form">
                <div class="grid">
                    <div class="form-group">
                        <label>SOCKS5 æœåŠ¡å™¨åœ°å€</label>
                        <input type="text" id="host" placeholder="proxy.example.com" value="${hasConfig ? currentConfig.socks5.host : ''}">
                    </div>
                    <div class="form-group">
                        <label>ç«¯å£</label>
                        <input type="number" id="port" placeholder="1080" value="${hasConfig ? currentConfig.socks5.port : '1080'}">
                    </div>
                </div>
                <div class="grid">
                    <div class="form-group">
                        <label>ç”¨æˆ·å (å¯é€‰)</label>
                        <input type="text" id="username" placeholder="ç•™ç©ºè¡¨ç¤ºæ— è®¤è¯" value="${hasConfig ? currentConfig.socks5.username : ''}">
                    </div>
                    <div class="form-group">
                        <label>å¯†ç  (å¯é€‰)</label>
                        <input type="password" id="password" placeholder="ç•™ç©ºè¡¨ç¤ºæ— è®¤è¯" value="${hasConfig ? currentConfig.socks5.password : ''}">
                    </div>
                </div>
                <button class="btn" onclick="generateURL()">ğŸ”— ç”Ÿæˆè®¿é—®é“¾æ¥</button>
                <div id="generatedURL" style="display: none; margin-top: 15px;">
                    <label>ç”Ÿæˆçš„URL:</label>
                    <div class="code" id="urlOutput"></div>
                    <button class="btn copy-btn" onclick="copyURL()">ğŸ“‹ å¤åˆ¶URL</button>
                </div>
            </div>

            ${hasConfig ? `
            <h2>ğŸ“¡ VLESSé…ç½®</h2>
            <div class="example-box">
                <strong>å½“å‰ä»£ç†çš„VLESSé“¾æ¥:</strong>
                <div class="code">${vlessLink}</div>
                <button class="btn copy-btn" onclick="copyVlessLink()">ğŸ“‹ å¤åˆ¶VLESSé“¾æ¥</button>
            </div>
            ` : ''}

            <h2>ğŸ“– æ”¯æŒçš„URLæ ¼å¼</h2>
            <div class="example-box">
                <strong>1ï¸âƒ£ æ— è®¤è¯ä»£ç†:</strong>
                <div class="code">${exampleUrl1}</div>
            </div>
            
            <div class="example-box">
                <strong>2ï¸âƒ£ å¸¦è®¤è¯çš„ä»£ç†:</strong>
                <div class="code">${exampleUrl2}</div>
            </div>
            
            <div class="example-box">
                <strong>3ï¸âƒ£ åŒ…å«é¢å¤–å‚æ•° (ed):</strong>
                <div class="code">${exampleUrl3}</div>
            </div>

            <h2>ğŸ”§ æ”¯æŒçš„åè®®</h2>
            <div class="alert alert-warning">
                <ul>
                    <li><code>socks://</code> - SOCKS5åè®® (ç®€å†™)</li>
                    <li><code>socks5://</code> - SOCKS5åè®® (æ ‡å‡†)</li>
                    <li>æ ¼å¼1: <code>socks5://host:port</code> (æ— è®¤è¯)</li>
                    <li>æ ¼å¼2: <code>socks5://user:pass@host:port</code> (å¸¦è®¤è¯)</li>
                </ul>
            </div>
        </div>

        <div class="card">
            <h2>ğŸ“Š å½“å‰çŠ¶æ€</h2>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">UUID</div>
                    <div class="info-value">${RUNTIME_CONFIG.userID.substring(0, 8)}***</div>
                </div>
                <div class="info-item">
                    <div class="info-label">SOCKS5çŠ¶æ€</div>
                    <div class="info-value">
                        <span class="status-badge ${hasConfig ? 'status-active' : 'status-inactive'}">
                            ${hasConfig ? 'âœ… å·²é…ç½®' : 'âŒ æœªé…ç½®'}
                        </span>
                    </div>
                </div>
                ${hasConfig ? `
                <div class="info-item">
                    <div class="info-label">ä»£ç†æœåŠ¡å™¨</div>
                    <div class="info-value">${currentConfig.socks5.host}:${currentConfig.socks5.port}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">è®¤è¯æ–¹å¼</div>
                    <div class="info-value">${currentConfig.socks5.username ? 'âœ… ç”¨æˆ·åå¯†ç ' : 'â­• æ— è®¤è¯'}</div>
                </div>
                ` : ''}
                <div class="info-item">
                    <div class="info-label">NAT64æœåŠ¡å™¨</div>
                    <div class="info-value">${RUNTIME_CONFIG.nat64Servers.length} ä¸ª</div>
                </div>
                <div class="info-item">
                    <div class="info-label">DNSæœåŠ¡å™¨</div>
                    <div class="info-value">${RUNTIME_CONFIG.dnsServer}</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const vlessLink = ${hasConfig ? JSON.stringify(vlessLink) : 'null'};
        const currentHost = '${host}';
        
        function generateURL() {
            const host = document.getElementById('host').value.trim();
            const port = document.getElementById('port').value.trim();
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();
            
            if (!host) {
                alert('âŒ è¯·è¾“å…¥SOCKS5æœåŠ¡å™¨åœ°å€');
                return;
            }
            
            let proxyUrl;
            if (username && password) {
                proxyUrl = \`socks5://\${encodeURIComponent(username)}:\${encodeURIComponent(password)}@\${host}:\${port || '1080'}\`;
            } else {
                proxyUrl = \`socks5://\${host}:\${port || '1080'}\`;
            }
            
            const fullUrl = \`https://\${currentHost}/?proxyip=\${encodeURIComponent(proxyUrl)}\`;
            
            document.getElementById('urlOutput').textContent = fullUrl;
            document.getElementById('generatedURL').style.display = 'block';
            
            window.generatedUrl = fullUrl;
        }
        
        function copyURL() {
            if (window.generatedUrl) {
                navigator.clipboard.writeText(window.generatedUrl).then(() => {
                    alert('âœ… URLå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                }).catch(() => {
                    alert('âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
                });
            }
        }
        
        function copyVlessLink() {
            if (vlessLink) {
                navigator.clipboard.writeText(vlessLink).then(() => {
                    alert('âœ… VLESSé“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                }).catch(() => {
                    alert('âŒ å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
                });
            }
        }
    </script>
</body>
</html>`;
}

class NAT64Manager {
  constructor(servers) {
    this.servers = [...servers];
    this.healthStatus = new Map();
    this.lastHealthCheck = new Map();
    this.currentIndex = 0;
    this.servers.forEach((server, index) => {
      this.healthStatus.set(index, true);
      this.lastHealthCheck.set(index, 0);
    });
  }

  getNextServer() {
    const now = Date.now();
    for (let i = 0; i < this.servers.length; i++) {
      const index = (this.currentIndex + i) % this.servers.length;
      const lastCheck = this.lastHealthCheck.get(index);
      if (now - lastCheck > 60000 || this.healthStatus.get(index)) {
        this.currentIndex = index;
        return { ...this.servers[index], index: index };
      }
    }
    this.currentIndex = 0;
    return { ...this.servers[0], index: 0 };
  }

  markServerUnhealthy(index) {
    this.healthStatus.set(index, false);
    this.lastHealthCheck.set(index, Date.now());
  }

  markServerHealthy(index) {
    this.healthStatus.set(index, true);
    this.lastHealthCheck.set(index, Date.now());
  }
}

let nat64Manager = new NAT64Manager(DEFAULT_NAT64_SERVERS);

export default {
  async fetch(request, env, ctx) {
    try {
      await loadConfigFromKV(env);
      
      const url = new URL(request.url);
      const upgradeHeader = request.headers.get('Upgrade');
      
      // ä»URLå‚æ•°ä¸­æå–é…ç½®
      const urlConfig = extractConfigFromURL(url);
      
      if (!upgradeHeader || upgradeHeader.toLowerCase() !== 'websocket') {
        // æ˜¾ç¤ºç®¡ç†é¡µé¢
        if (url.pathname === '/' || url.pathname === '/admin') {
          const host = request.headers.get('Host');
          return new Response(generateWebPage(host, urlConfig), {
            status: 200,
            headers: { 'Content-Type': 'text/html;charset=utf-8' },
          });
        }
        
        // API: è·å–å½“å‰é…ç½®
        if (url.pathname === '/api/config') {
          return new Response(JSON.stringify({
            uuid: RUNTIME_CONFIG.userID,
            socks5: urlConfig.socks5,
            nat64Servers: RUNTIME_CONFIG.nat64Servers,
            dnsServer: RUNTIME_CONFIG.dnsServer
          }, null, 2), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
          });
        }
        
        // çŠ¶æ€æŸ¥è¯¢
        if (url.pathname === '/status') {
          const status = {
            uuid: RUNTIME_CONFIG.userID.substring(0, 8) + '***',
            socks5_configured: !!urlConfig.socks5,
            socks5_info: urlConfig.socks5 ? {
              host: urlConfig.socks5.host,
              port: urlConfig.socks5.port,
              has_auth: !!(urlConfig.socks5.username && urlConfig.socks5.password)
            } : null,
            nat64_servers: nat64Manager.servers.length,
            dns_server: RUNTIME_CONFIG.dnsServer
          };
          return new Response(JSON.stringify(status, null, 2), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
          });
        }
        
        return new Response('Not Found', { status: 404 });
      }
      
      // WebSocketè¿æ¥ - åº”ç”¨URLå‚æ•°ä¸­çš„é…ç½®
      if (urlConfig.error) {
        return new Response(urlConfig.error, { status: 400 });
      }
      
      RUNTIME_CONFIG.socks5 = urlConfig.socks5;
      
      return await handleVLESSWebSocket(request);
    } catch (err) {
      return new Response(err.toString(), { status: 500 });
    }
  },
};

async function handleVLESSWebSocket(request) {
  const wsPair = new WebSocketPair();
  const [clientWS, serverWS] = Object.values(wsPair);
  serverWS.accept();

  const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';
  const wsReadable = createWebSocketReadableStream(serverWS, earlyDataHeader);
  let remoteSocket = null;
  let udpStreamWrite = null;
  let isDns = false;
  
  wsReadable.pipeTo(new WritableStream({
    async write(chunk) {
      if (isDns && udpStreamWrite) {
        return udpStreamWrite(chunk);
      }
      
      if (remoteSocket) {
        const writer = remoteSocket.writable.getWriter();
        await writer.write(chunk);
        writer.releaseLock();
        return;
      }

      const result = parseVLESSHeader(chunk, RUNTIME_CONFIG.userID);
      if (result.hasError) {
        throw new Error(result.message);
      }

      const vlessRespHeader = new Uint8Array([result.vlessVersion[0], 0]);
      const rawClientData = chunk.slice(result.rawDataIndex);
      
      if (result.isUDP) {
        if (result.portRemote === 53) {
          isDns = true;
          const { write } = await handleUDPOutBound(serverWS, vlessRespHeader);
          udpStreamWrite = write;
          udpStreamWrite(rawClientData);
          return;
        } else {
          throw new Error('UDPä»£ç†ä»…æ”¯æŒDNS(ç«¯å£53)');
        }
      }

      try {
        // å¦‚æœé…ç½®äº†SOCKS5ï¼Œä¼˜å…ˆä½¿ç”¨
        if (RUNTIME_CONFIG.socks5 && RUNTIME_CONFIG.socks5.enabled) {
          try {
            const socks5Socket = await connectViaSocks5(result.addressRemote, result.portRemote, rawClientData);
            remoteSocket = socks5Socket;
            pipeRemoteToWebSocket(socks5Socket, serverWS, vlessRespHeader, null);
            return;
          } catch (socks5Error) {
            console.error('SOCKS5è¿æ¥å¤±è´¥:', socks5Error.message);
          }
        }
        
        // SOCKS5å¤±è´¥æˆ–æœªé…ç½®ï¼Œå°è¯•NAT64
        try {
          const tcpSocket = await tryNAT64Connect(result.addressRemote, result.portRemote, rawClientData);
          remoteSocket = tcpSocket;
          pipeRemoteToWebSocket(tcpSocket, serverWS, vlessRespHeader, null);
        } catch (nat64Error) {
          console.error('NAT64è¿æ¥å¤±è´¥:', nat64Error.message);
          
          // æœ€åå°è¯•ç›´æ¥è¿æ¥
          try {
            const tcpSocket = await directConnect(result.addressRemote, result.portRemote, rawClientData);
            remoteSocket = tcpSocket;
            pipeRemoteToWebSocket(tcpSocket, serverWS, vlessRespHeader, null);
          } catch (directError) {
            console.error('ç›´æ¥è¿æ¥å¤±è´¥:', directError.message);
            serverWS.close(1011, 'æ‰€æœ‰è¿æ¥æ–¹å¼éƒ½å¤±è´¥');
          }
        }
      } catch (generalError) {
        console.error('è¿æ¥è¿‡ç¨‹ä¸­å‡ºç°æ„å¤–é”™è¯¯:', generalError);
        serverWS.close(1011, `è¿æ¥å¤±è´¥: ${generalError.message}`);
      }
    },
    close() {
      if (remoteSocket) {
        closeSocket(remoteSocket);
      }
    }
  })).catch(err => {
    console.error('WebSocket é”™è¯¯:', err);
    closeSocket(remoteSocket);
    serverWS.close(1011, 'å†…éƒ¨é”™è¯¯');
  });

  return new Response(null, {
    status: 101,
    webSocket: clientWS,
  });
}

async function connectViaSocks5(targetHost, targetPort, rawClientData) {
  const socks5Socket = await connect({
    hostname: RUNTIME_CONFIG.socks5.host,
    port: RUNTIME_CONFIG.socks5.port
  });

  const writer = socks5Socket.writable.getWriter();
  const reader = socks5Socket.readable.getReader();

  try {
    // åˆ¤æ–­æ˜¯å¦éœ€è¦è®¤è¯
    const needAuth = RUNTIME_CONFIG.socks5.username && RUNTIME_CONFIG.socks5.password;
    
    // å‘é€è®¤è¯æ–¹æ³•
    const authMethods = needAuth ? 
      new Uint8Array([0x05, 0x01, 0x02]) :  // æ”¯æŒç”¨æˆ·åå¯†ç è®¤è¯
      new Uint8Array([0x05, 0x01, 0x00]);   // æ— éœ€è®¤è¯
    
    await writer.write(authMethods);
    const authResponse = await reader.read();
    const authData = new Uint8Array(authResponse.value);
    
    if (authData[0] !== 0x05) {
      throw new Error('SOCKS5ç‰ˆæœ¬åå•†å¤±è´¥');
    }

    // å¦‚æœéœ€è¦è®¤è¯
    if (needAuth) {
      if (authData[1] !== 0x02) {
        throw new Error('SOCKS5æœåŠ¡å™¨ä¸æ”¯æŒç”¨æˆ·åå¯†ç è®¤è¯');
      }
      
      const username = new TextEncoder().encode(RUNTIME_CONFIG.socks5.username);
      const password = new TextEncoder().encode(RUNTIME_CONFIG.socks5.password);
      const authPacket = new Uint8Array(3 + username.length + password.length);
      
      authPacket[0] = 0x01;
      authPacket[1] = username.length;
      authPacket.set(username, 2);
      authPacket[2 + username.length] = password.length;
      authPacket.set(password, 3 + username.length);
      
      await writer.write(authPacket);
      const authResult = await reader.read();
      const authResultData = new Uint8Array(authResult.value);
      
      if (authResultData.length < 2 || authResultData[1] !== 0x00) {
        throw new Error('SOCKS5ç”¨æˆ·åå¯†ç è®¤è¯å¤±è´¥');
      }
    } else if (authData[1] !== 0x00) {
      throw new Error('SOCKS5æœåŠ¡å™¨è¦æ±‚è®¤è¯ï¼Œä½†æœªæä¾›è®¤è¯ä¿¡æ¯');
    }

    // å‘é€è¿æ¥è¯·æ±‚
    const hostBytes = new TextEncoder().encode(targetHost);
    const connectPacket = new Uint8Array(7 + hostBytes.length);
    
    connectPacket[0] = 0x05;  // SOCKSç‰ˆæœ¬
    connectPacket[1] = 0x01;  // CONNECTå‘½ä»¤
    connectPacket[2] = 0x00;  // ä¿ç•™å­—æ®µ
    connectPacket[3] = 0x03;  // åŸŸåç±»å‹
    connectPacket[4] = hostBytes.length;
    connectPacket.set(hostBytes, 5);
    connectPacket[5 + hostBytes.length] = (targetPort >> 8) & 0xFF;
    connectPacket[6 + hostBytes.length] = targetPort & 0xFF;
    
    await writer.write(connectPacket);
    const connectResponse = await reader.read();
    const connectData = new Uint8Array(connectResponse.value);
    
    if (connectData.length < 2 || connectData[1] !== 0x00) {
      throw new Error(`SOCKS5è¿æ¥å¤±è´¥ï¼Œé”™è¯¯ç : ${connectData[1]}`);
    }

    reader.releaseLock();
    writer.releaseLock();

    const dataWriter = socks5Socket.writable.getWriter();
    await dataWriter.write(rawClientData);
    dataWriter.releaseLock();

    return socks5Socket;
  } catch (err) {
    try {
      reader.releaseLock();
      writer.releaseLock();
    } catch (e) {}
    closeSocket(socks5Socket);
    throw err;
  }
}

async function tryNAT64Connect(domain, port, rawClientData) {
  let lastError = null;
  
  for (let attempt = 0; attempt < RUNTIME_CONFIG.nat64Servers.length; attempt++) {
    const nat64Server = nat64Manager.getNextServer();
    
    try {
      const proxyIP = await getIPv6ProxyAddress(domain, nat64Server);
      const connectPromise = connect({ hostname: proxyIP, port: port });
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('è¿æ¥è¶…æ—¶')), nat64Server.timeout);
      });
      
      const tcpSocket = await Promise.race([connectPromise, timeoutPromise]);
      nat64Manager.markServerHealthy(nat64Server.index);
      
      const writer = tcpSocket.writable.getWriter();
      await writer.write(rawClientData);
      writer.releaseLock();
      
      return tcpSocket;
    } catch (err) {
      lastError = err;
      nat64Manager.markServerUnhealthy(nat64Server.index);
      
      if (attempt < RUNTIME_CONFIG.nat64Servers.length - 1) {
        continue;
      }
    }
  }
  
  throw new Error(`æ‰€æœ‰NAT64æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼Œæœ€åé”™è¯¯: ${lastError?.message}`);
}

async function directConnect(address, port, rawClientData) {
  const tcpSocket = await connect({ hostname: address, port: port });
  const writer = tcpSocket.writable.getWriter();
  await writer.write(rawClientData);
  writer.releaseLock();
  return tcpSocket;
}

async function getIPv6ProxyAddress(domain, nat64Server) {
  const dnsQuery = await fetch(`${RUNTIME_CONFIG.dnsServer}?name=${domain}&type=A`, {
    headers: { 'Accept': 'application/dns-json' }
  });
  
  const dnsResult = await dnsQuery.json();
  if (dnsResult.Answer && dnsResult.Answer.length > 0) {
    const aRecord = dnsResult.Answer.find(record => record.type === 1);
    if (aRecord) {
      const ipv4Address = aRecord.data;
      return convertToNAT64IPv6(ipv4Address, nat64Server.prefix);
    }
  }
  throw new Error('æ— æ³•è§£æåŸŸåçš„IPv4åœ°å€');
}

function convertToNAT64IPv6(ipv4Address, nat64Prefix) {
  const parts = ipv4Address.split('.');
  if (parts.length !== 4) throw new Error('æ— æ•ˆçš„IPv4åœ°å€');
  
  const hex = parts.map(part => {
    const num = parseInt(part, 10);
    if (num < 0 || num > 255) throw new Error('æ— æ•ˆçš„IPv4åœ°å€æ®µ');
    return num.toString(16).padStart(2, '0');
  });
  
  if (nat64Prefix === '64:ff9b') {
    return `[64:ff9b::${hex[0]}${hex[1]}:${hex[2]}${hex[3]}]`;
  } else if (nat64Prefix.includes('::')) {
    return `[${nat64Prefix}:${hex[0]}${hex[1]}:${hex[2]}${hex[3]}]`;
  } else {
    return `[${nat64Prefix}::${hex[0]}${hex[1]}:${hex[2]}${hex[3]}]`;
  }
}

function createWebSocketReadableStream(ws, earlyDataHeader) {
  return new ReadableStream({
    start(controller) {
      ws.addEventListener('message', event => {
        controller.enqueue(event.data);
      });
      
      ws.addEventListener('close', () => {
        controller.close();
      });
      
      ws.addEventListener('error', err => {
        controller.error(err);
      });
      
      if (earlyDataHeader) {
        try {
          const decoded = atob(earlyDataHeader.replace(/-/g, '+').replace(/_/g, '/'));
          const data = Uint8Array.from(decoded, c => c.charCodeAt(0));
          controller.enqueue(data.buffer);
        } catch (e) {}
      }
    }
  });
}

function parseVLESSHeader(buffer, userID) {
  if (buffer.byteLength < 24) {
    return { hasError: true, message: 'æ— æ•ˆçš„å¤´éƒ¨é•¿åº¦' };
  }
  
  const view = new DataView(buffer);
  const version = new Uint8Array(buffer.slice(0, 1));
  
  const uuid = formatUUID(new Uint8Array(buffer.slice(1, 17)));
  if (uuid !== userID) {
    return { hasError: true, message: 'æ— æ•ˆçš„ç”¨æˆ·' };
  }
  
  const optionsLength = view.getUint8(17);
  const command = view.getUint8(18 + optionsLength);
  
  let isUDP = false;
  if (command === 1) {
  } else if (command === 2) {
    isUDP = true;
  } else {
    return { hasError: true, message: 'ä¸æ”¯æŒçš„å‘½ä»¤ï¼Œä»…æ”¯æŒTCP(01)å’ŒUDP(02)' };
  }
  
  let offset = 19 + optionsLength;
  const port = view.getUint16(offset);
  offset += 2;
  
  const addressType = view.getUint8(offset++);
  let address = '';
  
  switch (addressType) {
    case 1:
      address = Array.from(new Uint8Array(buffer.slice(offset, offset + 4))).join('.');
      offset += 4;
      break;
      
    case 2:
      const domainLength = view.getUint8(offset++);
      address = new TextDecoder().decode(buffer.slice(offset, offset + domainLength));
      offset += domainLength;
      break;
      
    case 3:
      const ipv6 = [];
      for (let i = 0; i < 8; i++) {
        ipv6.push(view.getUint16(offset).toString(16).padStart(4, '0'));
        offset += 2;
      }
      address = ipv6.join(':').replace(/(^|:)0+(\w)/g, '$1$2');
      break;
      
    default:
      return { hasError: true, message: 'ä¸æ”¯æŒçš„åœ°å€ç±»å‹' };
  }
  
  return {
    hasError: false,
    addressRemote: address,
    portRemote: port,
    rawDataIndex: offset,
    vlessVersion: version,
    isUDP
  };
}

function pipeRemoteToWebSocket(remoteSocket, ws, vlessHeader, retry = null) {
  let headerSent = false;
  let hasIncomingData = false;
  
  remoteSocket.readable.pipeTo(new WritableStream({
    write(chunk) {
      hasIncomingData = true;
      if (ws.readyState === WS_READY_STATE_OPEN) {
        if (!headerSent) {
          const combined = new Uint8Array(vlessHeader.byteLength + chunk.byteLength);
          combined.set(new Uint8Array(vlessHeader), 0);
          combined.set(new Uint8Array(chunk), vlessHeader.byteLength);
          ws.send(combined.buffer);
          headerSent = true;
        } else {
          ws.send(chunk);
        }
      }
    },
    close() {
      if (!hasIncomingData && retry) {
        retry();
        return;
      }
      if (ws.readyState === WS_READY_STATE_OPEN) {
        ws.close(1000, 'æ­£å¸¸å…³é—­');
      }
    },
    abort() {
      closeSocket(remoteSocket);
    }
  })).catch(err => {
    console.error('æ•°æ®è½¬å‘é”™è¯¯:', err);
    closeSocket(remoteSocket);
    if (ws.readyState === WS_READY_STATE_OPEN) {
      ws.close(1011, 'æ•°æ®ä¼ è¾“é”™è¯¯');
    }
  });
}

function closeSocket(socket) {
  if (socket) {
    try {
      socket.close();
    } catch (e) {}
  }
}

function formatUUID(bytes) {
  const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');
  return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
}

async function handleUDPOutBound(webSocket, vlessResponseHeader) {
  let isVlessHeaderSent = false;
  const transformStream = new TransformStream({
    start(controller) {},
    transform(chunk, controller) {
      for (let index = 0; index < chunk.byteLength;) {
        const lengthBuffer = chunk.slice(index, index + 2);
        const udpPacketLength = new DataView(lengthBuffer).getUint16(0);
        const udpData = new Uint8Array(
          chunk.slice(index + 2, index + 2 + udpPacketLength)
        );
        index = index + 2 + udpPacketLength;
        controller.enqueue(udpData);
      }
    },
    flush(controller) {}
  });

  transformStream.readable.pipeTo(new WritableStream({
    async write(chunk) {
      const resp = await fetch(RUNTIME_CONFIG.dnsServer, {
        method: 'POST',
        headers: { 'content-type': 'application/dns-message' },
        body: chunk,
      });
      const dnsQueryResult = await resp.arrayBuffer();
      const udpSize = dnsQueryResult.byteLength;
      const udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]);
      
      if (webSocket.readyState === WS_READY_STATE_OPEN) {
        if (isVlessHeaderSent) {
          webSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer());
        } else {
          webSocket.send(await new Blob([vlessResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer());
          isVlessHeaderSent = true;
        }
      }
    }
  })).catch((error) => {
    console.error('DNS UDPå¤„ç†é”™è¯¯:', error);
  });

  const writer = transformStream.writable.getWriter();

  return {
    write(chunk) {
      writer.write(chunk);
    }
  };
}
